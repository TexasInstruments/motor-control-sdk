;
; Copyright (C) 2024 Texas Instruments Incorporated
;
; Redistribution and use in source and binary forms, with or without
; modification, are permitted provided that the following conditions
; are met:
;
;   Redistributions of source code must retain the above copyright
;   notice, this list of conditions and the following disclaimer.
;
;   Redistributions in binary form must reproduce the above copyright
;   notice, this list of conditions and the following disclaimer in the
;   documentation and/or other materials provided with the
;   distribution.
;
;   Neither the name of Texas Instruments Incorporated nor the names of
;   its contributors may be used to endorse or promote products derived
;   from this software without specific prior written permission.
;
; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
; "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
; LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
; OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
; SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
; LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;

;************************************************************************************
;*   File:     nikon_main.asm                                            	    *
;*                                                                                  *
;*   Brief:    Firmware initialization, Storing position data, Control communication*
;************************************************************************************

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;/
; Assembler Directives Section
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;/
	.sect   ".text"
	.retain		; Required for building .out with assembly file
	.retainrefs ; Required for building .out with assembly file
	.global NIKON_INIT


	.include "nikon_icss_reg_defs.h"
	.include "nikon_params.h"
	.include "nikon_interface.h"
	.include "firmware_version.h"
	.include "nikon_macros.h"

	;nikon main starts from here
NIKON_INIT:
    JMP         NIKON_MAIN
    .word       ICSS_FIRMWARE_RELEASE_1,	ICSS_FIRMWARE_RELEASE_2
NIKON_MAIN:
	.if	$isdefed("PRU0") | $isdefed("RTU_PRU0") | $isdefed("TX_PRU0")
	.asg	c24,	PRU0_DMEM
	.asg	c25,	PRU1_DMEM
	.asg	PRU0_DMEM,		PRUx_DMEM
	.asg	PRU0_DMEM,		PRUx_DMEM
	.asg    ICSS_CFG_PRU0_ENDAT_CH0_CFG1, ICSS_CFG_PRUx_NIKON_CH0_CFG1
	.asg    ICSS_CFG_PRU0_ENDAT_CH1_CFG1, ICSS_CFG_PRUx_NIKON_CH1_CFG1
	.asg    ICSS_CFG_PRU0_ENDAT_CH2_CFG1, ICSS_CFG_PRUx_NIKON_CH2_CFG1
	.asg    ICSS_CFG_PRU0_ENDAT_CH0_CFG0, ICSS_CFG_PRUx_NIKON_CH0_CFG0
	.asg    ICSS_CFG_PRU0_ENDAT_CH1_CFG0, ICSS_CFG_PRUx_NIKON_CH1_CFG0
	.asg    ICSS_CFG_PRU0_ENDAT_CH2_CFG0, ICSS_CFG_PRUx_NIKON_CH2_CFG0
	.asg    ICSS_CFG_PRU0_ENDAT_TXCFG,    ICSS_CFG_PRUx_NIKON_TXCFG
	.asg    ICSS_CFG_PRU0_ENDAT_RXCFG,    ICSS_CFG_PRUx_NIKON_RXCFG
	.endif

	.if	$isdefed("PRU1") | $isdefed("RTU_PRU1") | $isdefed("TX_PRU1")
	.asg	c24,	PRU1_DMEM
	.asg	c25,	PRU0_DMEM
	.asg	PRU0_DMEM,		PRUx_DMEM
	.asg	PRU1_DMEM,		PRUx_DMEM
	.asg    ICSS_CFG_PRU1_ENDAT_CH0_CFG1, ICSS_CFG_PRUx_NIKON_CH0_CFG1
	.asg    ICSS_CFG_PRU1_ENDAT_CH1_CFG1, ICSS_CFG_PRUx_NIKON_CH1_CFG1
	.asg    ICSS_CFG_PRU1_ENDAT_CH2_CFG1, ICSS_CFG_PRUx_NIKON_CH2_CFG1
	.asg    ICSS_CFG_PRU1_ENDAT_CH0_CFG0, ICSS_CFG_PRUx_NIKON_CH0_CFG0
	.asg    ICSS_CFG_PRU1_ENDAT_CH1_CFG0, ICSS_CFG_PRUx_NIKON_CH1_CFG0
	.asg    ICSS_CFG_PRU1_ENDAT_CH2_CFG0, ICSS_CFG_PRUx_NIKON_CH2_CFG0
	.asg    ICSS_CFG_PRU1_ENDAT_TXCFG,    ICSS_CFG_PRUx_NIKON_TXCFG
	.asg    ICSS_CFG_PRU1_ENDAT_RXCFG,    ICSS_CFG_PRUx_NIKON_RXCFG
	.endif
	.if $isdefed("ENABLE_MULTI_MAKE_TXPRU")
	.asg 	c28, ICSS_PRU_CTRL_CONST
	.else
	.asg 	c11, ICSS_PRU_CTRL_CONST
	.endif

	; clear all registers
	ZERO	&HW_CONFIG,	120
	LBCO 	&CH_MASK, PRUx_DMEM, NIKON_CHANNEL_CONFIG_OFFSET, 1
	.if $isdefed("ENABLE_MULTI_MAKE_RTU")
	LDI 	CH_MASK, 	0x1
	.elseif $isdefed("ENABLE_MULTI_MAKE_PRU")
	LDI 	CH_MASK, 	0x2
	.elseif $isdefed("ENABLE_MULTI_MAKE_TXPRU")
	LDI 	CH_MASK, 	0x4
	.endif

	; Configure  RX Enable counter with 2(non zero value)
	LDI     SCRATCH1.w0, 0							;wire delay
    LDI     SCRATCH1.w2, NIKON_AUTO_ARM_DELAY		;non-zero auto arm delay to enable Rx automatically
	QBBC 	NIKON_CH1_AUTO_ARM?, CH_MASK, 0
    LDI     SCRATCH.w0, ICSS_CFG_PRUx_NIKON_CH0_CFG1
	SBCO    &SCRATCH1, ICSS_CFG, SCRATCH.w0, 4
NIKON_CH1_AUTO_ARM?:
	QBBC 	NIKON_CH2_AUTO_ARM?, CH_MASK, 1
	LDI 	SCRATCH.w0, ICSS_CFG_PRUx_NIKON_CH1_CFG1
	SBCO    &SCRATCH1, ICSS_CFG, SCRATCH.w0, 4
NIKON_CH2_AUTO_ARM?:
	QBBC	NIKON_SKIP_AUTO_ARM?, CH_MASK, 2
	LDI 	SCRATCH.w0, ICSS_CFG_PRUx_NIKON_CH2_CFG1
	SBCO    &SCRATCH1, ICSS_CFG, SCRATCH.w0, 4
NIKON_SKIP_AUTO_ARM?:
	LBCO 	&PRIMARY_CORE, PRUx_DMEM, NIKON_PRIMARY_CORE_MASK_OFFSET, 1

NIKON_CHECK_OPERATING_MODE:
	.if $isdefed("ENABLE_MULTI_MAKE_RTU")
	LBCO	&SCRATCH2.b0,	PRUx_DMEM, 	NIKON_OPMODE_RTU_CONFIG_OFFSET,	1
	.elseif $isdefed("ENABLE_MULTI_MAKE_PRU")
	LBCO	&SCRATCH2.b0,	PRUx_DMEM, 	NIKON_OPMODE_PRU_CONFIG_OFFSET,	1
	.elseif $isdefed("ENABLE_MULTI_MAKE_TXPRU")
	LBCO 	&SCRATCH2.b0, 	PRUx_DMEM, 	NIKON_OPMODE_TXPRU_CONFIG_OFFSET, 1
	.else
	LBCO 	&SCRATCH2.b0, 	PRUx_DMEM, 	NIKON_OPMODE_CONFIG_OFFSET, 1
	.endif
    ;If opmode=1, Host trigger
	;If opmode=0, Periodic trigger
	QBNE	NIKON_HANDLE_HOST_TRIGGER,	SCRATCH2.b0,		0

NIKON_HANDLE_PERIODIC_TRIGGER:
    ;Get compare event status
	LBCO	&SCRATCH1,	ICSS_IEP,	ICSS_IEP_CMP_STATUS_REG,	4
    ; wait till IEP CMP3 event
	QBBC 	NIKON_CHECK_OPERATING_MODE,	SCRATCH1,	3
	; Clear IEP CMP3 event
	SET		SCRATCH1,	SCRATCH1,	3
    ; store compare event status
    SBCO	&SCRATCH1,	ICSS_IEP,  ICSS_IEP_CMP_STATUS_REG,	4
NIKON_SKIP_IEP_CMP_STATUS?:
    ; SET command TRIGGER
    LDI		SCRATCH1.b0,	1
	.if $isdefed("ENABLE_MULTI_MAKE_RTU")
	SBCO    &SCRATCH1.b0,	PRUx_DMEM, NIKON_HOST_TRIGGER_STATUS_RTU_OFFSET,	1
	.elseif $isdefed("ENABLE_MULTI_MAKE_PRU")
	SBCO    &SCRATCH1.b0,	PRUx_DMEM, NIKON_HOST_TRIGGER_STATUS_PRU_OFFSET,	1
	.elseif $isdefed("ENABLE_MULTI_MAKE_TXPRU")
	SBCO    &SCRATCH1.b0,	PRUx_DMEM, NIKON_HOST_TRIGGER_STATUS_TXPRU_OFFSET,	1
	.else
	SBCO    &SCRATCH1.b0,	PRUx_DMEM, NIKON_HOST_TRIGGER_STATUS_OFFSET,	1
	.endif
NIKON_HANDLE_HOST_TRIGGER:

    ;If Host Trigger=1, request made by R5F to Firmware, now Firmware do processing and when done set trigger to 0 so that R5F application can act further.
	.if $isdefed("ENABLE_MULTI_MAKE_RTU")
	LBCO	&SCRATCH.b0,	PRUx_DMEM, NIKON_HOST_TRIGGER_STATUS_RTU_OFFSET, 1
	.elseif $isdefed("ENABLE_MULTI_MAKE_PRU")
	LBCO 	&SCRATCH.b0,	PRUx_DMEM, NIKON_HOST_TRIGGER_STATUS_PRU_OFFSET, 1
	.elseif $isdefed("ENABLE_MULTI_MAKE_TXPRU")
	LBCO 	&SCRATCH.b0,	PRUx_DMEM, NIKON_HOST_TRIGGER_STATUS_TXPRU_OFFSET, 1
	.else
	LBCO 	&SCRATCH.b0,	PRUx_DMEM, NIKON_HOST_TRIGGER_STATUS_OFFSET, 1
	.endif
	QBEQ	NIKON_CHECK_OPERATING_MODE, SCRATCH.b0, 0

	LBCO 	&VALID_BIT_IDX, PRUx_DMEM, NIKON_VALID_BIT_IDX_OFFSET, 1
	LBCO 	&FIFO_BIT_IDX, PRUx_DMEM, NIKON_FIFO_BIT_IDX_OFFSET, 1
	QBBS 	NIKON_IS_CH0?, CH_MASK, 0
NIKON_IS_CH1?:
	QBBC 	NIKON_IS_CH2?, CH_MASK, 1
	ADD 	FIFO_BIT_IDX, FIFO_BIT_IDX, 8
	ADD 	VALID_BIT_IDX, VALID_BIT_IDX, 1
	QBA		NIKON_IS_CH0?
NIKON_IS_CH2?:
	QBBC 	NIKON_IS_CH0?, CH_MASK, 2
	ADD 	FIFO_BIT_IDX, FIFO_BIT_IDX, 16
	ADD 	VALID_BIT_IDX, VALID_BIT_IDX, 2
NIKON_IS_CH0?:

	;TX Global reinit to reset the HW interface
	.if $isdefed("ENABLE_MULTI_MAKE_RTU")
	M_NIKON_LS_WAIT_FOR_SYNC
	QBBC 	NIKON_CLK_CONFIG, PRIMARY_CORE, 0
    SET     R31, NIKON_TX_GLOBAL_REINIT
	.elseif $isdefed("ENABLE_MULTI_MAKE_PRU")
	M_NIKON_LS_WAIT_FOR_SYNC
	QBBC 	NIKON_CLK_CONFIG, PRIMARY_CORE, 1
	SET 	R31, NIKON_TX_GLOBAL_REINIT
	.elseif $isdefed("ENABLE_MULTI_MAKE_TXPRU")
	M_NIKON_LS_WAIT_FOR_SYNC
	QBBC 	NIKON_CLK_CONFIG, PRIMARY_CORE, 2
	SET 	R31, NIKON_TX_GLOBAL_REINIT
	.else
	SET 	R31, NIKON_TX_GLOBAL_REINIT
	.endif

NIKON_CLK_CONFIG:
	.if $isdefed("ENABLE_MULTI_MAKE_RTU")
	LBCO 	&CDF_FRAME, PRUx_DMEM, NIKON_COMMAND_DATA_FRAME_RTU_OFFSET, 4
	.elseif $isdefed("ENABLE_MULTI_MAKE_PRU")
	LBCO 	&CDF_FRAME, PRUx_DMEM, NIKON_COMMAND_DATA_FRAME_PRU_OFFSET, 4
	.elseif $isdefed("ENABLE_MULTI_MAKE_TXPRU")
	LBCO 	&CDF_FRAME, PRUx_DMEM, NIKON_COMMAND_DATA_FRAME_TXPRU_OFFSET, 4
	.else
	LBCO 	&CDF_FRAME, PRUx_DMEM, NIKON_COMMAND_DATA_FRAME_OFFSET, 4
	.endif
	LBCO 	&SCRATCH2.b0, PRUx_DMEM, NIKON_RX_FRAME_SIZE_CONFIG, 2
	QBBC 	NIKON_CH1_RX_SIZE, CH_MASK, 0
	;store rx frame size for channel 0 in ICSS_CFG_PRUx_ED_CH0
	LDI     SCRATCH.w2, ICSS_CFG_PRUx_NIKON_CH0_CFG0+2
	SBCO	&SCRATCH2.w0,	ICSS_CFG,	SCRATCH.w2,	2
NIKON_CH1_RX_SIZE:
	QBBC 	NIKON_CH2_RX_SIZE, CH_MASK, 1
    ;store rx frame size for channel 1 in ICSS_CFG_PRUx_ED_CH1
	LDI     SCRATCH.w2, ICSS_CFG_PRUx_NIKON_CH1_CFG0+2
	SBCO	&SCRATCH2.w0,	ICSS_CFG,	SCRATCH.w2,	2
NIKON_CH2_RX_SIZE:
	QBBC 	NIKON_SKIP_RX_SIZE, CH_MASK, 2
    ;store rx frame size for channel 2 in ICSS_CFG_PRUx_ED_CH2
	LDI     SCRATCH.w2, ICSS_CFG_PRUx_NIKON_CH2_CFG0+2
	SBCO	&SCRATCH2.w0,	ICSS_CFG,	SCRATCH.w2,	2
NIKON_SKIP_RX_SIZE:
	ZERO 	&SCRATCH, 4
	SBCO 	&SCRATCH, PRUx_DMEM, NIKON_LS_RTU_SYNC_STATUS_OFFSET, 3
	LBCO 	&EEPROM_ACCESS_STATUS, PRUx_DMEM, NIKON_MEM_ACCESS_STATUS_OFFSET, 1
	QBEQ 	NIKON_TX_IN_SINGLESHOT_MODE, EEPROM_ACCESS_STATUS, NON_EEPROM_CMD
NIKON_TX_IN_CONTINUOUS_MODE:
	LDI 	SCRATCH2.b3, NUM_OF_NIKON_CYC_FOR_EEPROM_ACCESS
	LDI		TX_MODE, TX_CONTINUOUS_MODE
	QBA 	NIKON_SKIP_TX
NIKON_TX_IN_SINGLESHOT_MODE:
	ZERO 	&MDF_FRAME, 4
	LDI 	TX_MODE, TX_SINGLE_SHOT

NIKON_SKIP_TX:
	NIKON_TX_SEND 	CDF_FRAME, MDF_FRAME
	.if $isdefed("ENABLE_MULTI_MAKE_RTU")
	LBCO 	&SCRATCH3.b0, PRUx_DMEM, NIKON_NUMBER_OF_ENCODERS_RTU_OFFSET, 1
	.elseif $isdefed("ENABLE_MULTI_MAKE_PRU")
	LBCO 	&SCRATCH3.b0, PRUx_DMEM, NIKON_NUMBER_OF_ENCODERS_PRU_OFFSET, 1
	.elseif $isdefed("ENABLE_MULTI_MAKE_TXPRU")
	LBCO 	&SCRATCH3.b0, PRUx_DMEM, NIKON_NUMBER_OF_ENCODERS_TXPRU_OFFSET, 1
	.else
	LBCO 	&SCRATCH3.b0, PRUx_DMEM, NIKON_NUMBER_OF_ENCODERS_OFFSET, 1
	.endif
	LDI 	ENCODER_OFFSET, NIKON_POSITION_DATA_ENC0_RES_OFFSET
	QBA 	NIKON_SKIP_MULTI_TRANSMISSION
NIKON_RCV_NEXT_ENC_DATA?:
	LBCO 	&SCRATCH, 	PRUx_DMEM, 	NIKON_CONFIG_MT_DELAY_OFFSET, 1
NIKON_MT_DELAY_LOOP:
	QBBC 	NIKON_MT_DELAY_LOOP, R31, VALID_BIT_IDX
	SUB 	SCRATCH.b0, SCRATCH.b0, 1
	SET 	R31, R31, VALID_BIT_IDX
	QBNE 	NIKON_MT_DELAY_LOOP, SCRATCH.b0, 0
NIKON_SKIP_MULTI_TRANSMISSION:

	.if $isdefed("ENABLE_MULTI_CHANNEL")
	ADD 	RAW_DATA_OFFSET, ENCODER_OFFSET, NIKON_INFO_FIELD_CH0_OFFSET
	ADD 	SCRATCH3.b1, ENCODER_OFFSET, NIKON_POS_DATA_CH0_CRC_ERROR_COUNT
	ADD 	SCRATCH3.b3, ENCODER_OFFSET, NIKON_POSITION_DATA_OTF_CRC_CH0_OFFSET
	.else
	QBBC 	NIKON_CH1_IN_USE?, CH_MASK, 0
	ADD 	RAW_DATA_OFFSET, ENCODER_OFFSET, NIKON_INFO_FIELD_CH0_OFFSET
	ADD 	SCRATCH3.b1, ENCODER_OFFSET, NIKON_POS_DATA_CH0_CRC_ERROR_COUNT
	ADD 	SCRATCH3.b3, ENCODER_OFFSET, NIKON_POSITION_DATA_OTF_CRC_CH0_OFFSET
NIKON_CH1_IN_USE?:
	QBBC 	NIKON_CH2_IN_USE?, CH_MASK, 1
	ADD 	RAW_DATA_OFFSET, ENCODER_OFFSET, NIKON_INFO_FIELD_CH1_OFFSET
	ADD 	SCRATCH3.b1, ENCODER_OFFSET, NIKON_POS_DATA_CH1_CRC_ERROR_COUNT
	ADD 	SCRATCH3.b3, ENCODER_OFFSET, NIKON_POSITION_DATA_OTF_CRC_CH1_OFFSET
NIKON_CH2_IN_USE?:
	QBBC 	NIKON_SKIP_CH_IN_USE?, CH_MASK, 2
	ADD 	RAW_DATA_OFFSET, ENCODER_OFFSET, NIKON_INFO_FIELD_CH2_OFFSET
	ADD 	SCRATCH3.b1, ENCODER_OFFSET, NIKON_POS_DATA_CH2_CRC_ERROR_COUNT
	ADD 	SCRATCH3.b3, ENCODER_OFFSET, NIKON_POSITION_DATA_OTF_CRC_CH2_OFFSET
	.endif
NIKON_SKIP_CH_IN_USE?:

	LBCO 	&SCRATCH2.b0, PRUx_DMEM, NIKON_NUMBER_OF_RX_FRAMES_OFFSET, 1
	ZERO    &SCRATCH, 4
    ZERO    &FF0, 48
	ZERO 	&EX, 4
    LDI     SCRATCH2.b1, DATA_SIZE_IN_EACH_FRAME
	LBCO 	&RX_FREQ, PRUx_DMEM, NIKON_RX_CLK_FREQ_CONFIG_OFFSET, 1
	QBNE 	NIKON_SKIP_16MHZ_RECEIVE, RX_FREQ, 16
	;Avoid On-the-fly calculation for 16MHz for cycle budgeting issue
	.if $isdefed("ENABLE_MULTI_CHANNEL")
	M_OTF_RECEIVE_16MHZ_MC RAW_DATA0, RAW_DATA1, RAW_DATA2, SCRATCH2.b0, SCRATCH.b2, RAW_DATA_OFFSET
	.else
	M_OTF_RECEIVE_16MHZ 	RAW_DATA0, SCRATCH2.b0, SCRATCH.b2, RAW_DATA_OFFSET
	.endif
	QBA 	NIKON_SKIP_RECEIVE
NIKON_SKIP_16MHZ_RECEIVE:
	.if $isdefed("ENABLE_MULTI_CHANNEL")
	M_OTF_RECEIVE_MC 	RAW_DATA0, RAW_DATA1, RAW_DATA2, SCRATCH2.b0, SCRATCH.b2, RAW_DATA_OFFSET
	.else
	M_OTF_RECEIVE 	RAW_DATA0, SCRATCH2.b0, SCRATCH.b2, RAW_DATA_OFFSET
	.endif
NIKON_SKIP_RECEIVE:
	SUB 	SCRATCH3.b0, SCRATCH3.b0, 1
	ADD 	ENCODER_OFFSET, ENCODER_OFFSET, (NIKON_POSITION_DATA_ENC1_RES_OFFSET - NIKON_POSITION_DATA_ENC0_RES_OFFSET)
	QBNE 	NIKON_RCV_NEXT_ENC_DATA?, SCRATCH3.b0, 0
	QBNE 	NIKON_CLEAR_CYCLE_TRIGGER, RX_FREQ, NIKON_16MHZ_FREQ
	NIKON_16MHZ_POST_PROCESSING
NIKON_CLEAR_CYCLE_TRIGGER:

	.if $isdefed("ENABLE_MULTI_MAKE_RTU")
	LBCO	&SCRATCH1.b0,	PRUx_DMEM, 	NIKON_OPMODE_RTU_CONFIG_OFFSET,	1
	.elseif $isdefed("ENABLE_MULTI_MAKE_PRU")
	LBCO	&SCRATCH1.b0,	PRUx_DMEM, 	NIKON_OPMODE_PRU_CONFIG_OFFSET,	1
	.elseif $isdefed("ENABLE_MULTI_MAKE_TXPRU")
	LBCO	&SCRATCH1.b0,	PRUx_DMEM, 	NIKON_OPMODE_TXPRU_CONFIG_OFFSET,	1
	.else
	LBCO 	&SCRATCH1.b0,	PRUx_DMEM,	NIKON_OPMODE_CONFIG_OFFSET, 1
	.endif
	;skip interrupt to R5F in host trigger
	LDI 	R30.b3, 0
	.if $isdefed("ENABLE_MULTI_MAKE_RTU")
	M_NIKON_LS_WAIT_FOR_SYNC
	QBBC 	NIKON_SKIP_GLOBAL_REINIT, PRIMARY_CORE, 0
    ;skip interrupt to R5F in host trigger
    QBNE    NIKON_SKIP_INTERRUPT_TRIGGER,  SCRATCH1.b0,  0
	;Generate interrupt to R5F
	LDI 	R31.w0, NIKON_PRU_TRIGGER_HOST_EVT				;PRU_TRIGGER_HOST_NIKON_EVT0 ( pr0_pru_mst_intr[2]_intr_req )
NIKON_SKIP_INTERRUPT_TRIGGER:
	SET     R31, NIKON_TX_GLOBAL_REINIT

	.elseif $isdefed("ENABLE_MULTI_MAKE_PRU")
	M_NIKON_LS_WAIT_FOR_SYNC
	QBBC 	NIKON_SKIP_GLOBAL_REINIT, PRIMARY_CORE, 1
	;skip interrupt to R5F in host trigger
    QBNE    NIKON_SKIP_INTERRUPT_TRIGGER,  SCRATCH1.b0,  0
	;Generate interrupt to R5F
	LDI 	R31.w0, NIKON_PRU_TRIGGER_HOST_EVT				;PRU_TRIGGER_HOST_NIKON_EVT0 ( pr0_pru_mst_intr[2]_intr_req )
NIKON_SKIP_INTERRUPT_TRIGGER:
	SET 	R31, NIKON_TX_GLOBAL_REINIT
	.elseif $isdefed("ENABLE_MULTI_MAKE_TXPRU")
	M_NIKON_LS_WAIT_FOR_SYNC
	QBBC 	NIKON_SKIP_GLOBAL_REINIT, PRIMARY_CORE, 2
	;skip interrupt to R5F in host trigger
    QBNE    NIKON_SKIP_INTERRUPT_TRIGGER,  SCRATCH1.b0,  0
	;Generate interrupt to R5F
	LDI 	R31.w0, NIKON_PRU_TRIGGER_HOST_EVT				;PRU_TRIGGER_HOST_NIKON_EVT0 ( pr0_pru_mst_intr[2]_intr_req )
NIKON_SKIP_INTERRUPT_TRIGGER:
	SET 	R31, NIKON_TX_GLOBAL_REINIT
	.else
	;skip interrupt to R5F in host trigger
    QBNE    NIKON_SKIP_INTERRUPT_TRIGGER,  SCRATCH1.b0,  0
	;Generate interrupt to R5F
	LDI 	R31.w0, NIKON_PRU_TRIGGER_HOST_EVT				;PRU_TRIGGER_HOST_NIKON_EVT0 ( pr0_pru_mst_intr[2]_intr_req )
NIKON_SKIP_INTERRUPT_TRIGGER:
	SET 	R31, NIKON_TX_GLOBAL_REINIT
	.endif
NIKON_SKIP_GLOBAL_REINIT:
	;Clear Host Trigger
	ZERO 	&SCRATCH, 4
	.if $isdefed("ENABLE_MULTI_MAKE_RTU")
	SBCO	&SCRATCH.b0, PRUx_DMEM, NIKON_HOST_TRIGGER_STATUS_RTU_OFFSET,	1
	.elseif $isdefed("ENABLE_MULTI_MAKE_PRU")
	SBCO	&SCRATCH.b0, PRUx_DMEM, NIKON_HOST_TRIGGER_STATUS_PRU_OFFSET,	1
	.elseif $isdefed("ENABLE_MULTI_MAKE_TXPRU")
	SBCO	&SCRATCH.b0, PRUx_DMEM, NIKON_HOST_TRIGGER_STATUS_TXPRU_OFFSET,	1
	.else
	SBCO	&SCRATCH.b0, PRUx_DMEM, NIKON_HOST_TRIGGER_STATUS_OFFSET,		1
	.endif

	;Handle next Position request by user.
    JMP		NIKON_CHECK_OPERATING_MODE
	;never reach here
	HALT

